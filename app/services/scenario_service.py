"""
Scenario generation service with Agent pattern integration.
Generates conversation scenarios from projects and schedules.
"""
import os
import logging
from typing import List, Dict, Any, Optional
import httpx

from app.config import settings
from app.models.scenario import Scenario
from sqlalchemy.orm import Session

from agent.scenario.generator_agent import ScenarioGeneratorAgent
from agent.scenario.modifier_agent import ScenarioModifierAgent
from app.core.file_utils import extract_text_from_file

logger = logging.getLogger(__name__)


class ScenarioService:
    """Service for generating and managing conversation scenarios."""

    def __init__(self):
        """Initialize with Agent pattern."""
        self.generator_agent = ScenarioGeneratorAgent()
        self.modifier_agent = ScenarioModifierAgent()

    async def generate_from_projects(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        language: str,
        difficulty: str,
        count: int,
        user_id: str,
        jwt_token: str,
        db: Session,
        save_to_db: bool = True
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios from projects and schedules using GPT-4o.

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            language: Target language (en, ko, zh, ja)
            difficulty: Difficulty level (beginner, intermediate, advanced)
            count: Number of scenarios to generate
            user_id: User UUID
            jwt_token: JWT token for Java API calls
            db: Database session
            save_to_db: Whether to save scenarios to DB (False for preview mode)

        Returns:
            List of generated scenario dictionaries
        """
        # 1. Fetch context from Java backend
        context = await self._fetch_context(project_ids, schedule_ids, document_ids, jwt_token)
        logger.info(f"ğŸ” [DEBUG] Context length: {len(context)} chars")
        logger.info(f"ğŸ” [DEBUG] Context preview:\n{context[:1500]}...")

        # 2. Generate scenarios with Agent pattern
        is_everyday = context == "General business communication scenarios for professional practice."
        scenarios_data = await self.generator_agent.process(
            context=context,
            language=language,
            difficulty=difficulty,
            count=count,
            is_everyday=is_everyday
        )

        # 3. Prepare response (and optionally save to PostgreSQL)
        result_scenarios = []
        for idx, scenario_data in enumerate(scenarios_data):
            try:
                if save_to_db:
                    # Save to DB mode
                    scenario = Scenario(
                        user_id=user_id,
                        title=scenario_data["title"],
                        description=scenario_data["description"],
                        scenario_text=scenario_data["scenarioText"],
                        language=language,
                        difficulty=difficulty,
                        category=scenario_data["category"],
                        roles=scenario_data["roles"],
                        required_terminology=scenario_data.get("requiredTerminology", []),
                        project_ids=project_ids,
                        schedule_ids=schedule_ids,
                        document_ids=document_ids,
                        auto_generated=True
                    )
                    db.add(scenario)
                    db.flush()

                    result_scenarios.append({
                        "id": str(scenario.id),
                        "title": scenario.title,
                        "description": scenario.description,
                        "scenarioText": scenario.scenario_text,
                        "language": scenario.language,
                        "difficulty": scenario.difficulty,
                        "category": scenario.category,
                        "roles": scenario.roles,
                        "requiredTerminology": scenario.required_terminology,
                        "autoGenerated": scenario.auto_generated,
                        "createdAt": scenario.created_at.isoformat()
                    })

                else:
                    # Preview mode - don't save to DB
                    result_scenarios.append({
                        "title": scenario_data["title"],
                        "description": scenario_data["description"],
                        "scenarioText": scenario_data["scenarioText"],
                        "language": language,
                        "difficulty": difficulty,
                        "category": scenario_data["category"],
                        "roles": scenario_data["roles"],
                        "requiredTerminology": scenario_data.get("requiredTerminology", []),
                        "autoGenerated": True
                    })

            except Exception as e:
                logger.error(f"âŒ Failed to process scenario {idx + 1}: {str(e)}")
                continue

        if save_to_db:
            db.commit()

        return result_scenarios

    async def _fetch_context(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        jwt_token: str
    ) -> str:
        """
        Fetch context from Java backend (projects, schedules, and documents).

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            jwt_token: JWT token for authentication

        Returns:
            Combined context string
        """
        headers = {"Authorization": f"Bearer {jwt_token}"}
        context_parts = []

        # Collect document IDs from projects (auto-fetch linked documents)
        all_document_ids = set(document_ids)  # Start with explicitly provided document IDs

        async with httpx.AsyncClient() as client:
            # Fetch project information
            for pid in project_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/projects/{pid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        response_data = response.json()
                        project = response_data.get('data', response_data)  # Handle ApiResponse wrapper
                        project_name = project.get('name', '')
                        project_desc = project.get('description', '')
                        context_parts.append(
                            f"Project: {project_name}\n"
                            f"Description: {project_desc}"
                        )
                        # Extract documentIds from project and add to fetch list
                        project_doc_ids = project.get('documentIds', [])
                        if project_doc_ids:
                            all_document_ids.update(project_doc_ids)
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch project {pid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch project {pid}: {str(e)}")

            # Fetch schedule information
            for sid in schedule_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/schedules/{sid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        schedule_data = response.json()
                        schedule = schedule_data.get('data', {})
                        schedule_title = schedule.get('title', '')
                        schedule_desc = schedule.get('description', '')
                        schedule_location = schedule.get('location', 'N/A')
                        context_parts.append(
                            f"Schedule: {schedule_title}\n"
                            f"Description: {schedule_desc}\n"
                            f"Location: {schedule_location}"
                        )
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: {str(e)}")

            # Fetch document contents (includes both explicit and project-linked documents)
            for doc_id in all_document_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/files/{doc_id}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        doc_data = response.json()
                        document = doc_data.get('data', {})

                        doc_filename = document.get('originalFilename', '')
                        file_path = document.get('filePath', '')

                        # Extract page contents (limit to first 5 pages, 500 chars per page)
                        contents = document.get('contents', [])[:5]
                        if contents:
                            text_parts = []
                            for content in contents:
                                page_text = content.get('contentText', '')[:500]
                                if page_text:
                                    text_parts.append(f"Page {content.get('pageNumber', '?')}: {page_text}")

                            if text_parts:
                                context_parts.append(
                                    f"Document: {doc_filename}\n"
                                    + "\n".join(text_parts)
                                )
                        else:
                            # Fallback: Extract text directly from file if contents is empty
                            if file_path:
                                try:
                                    full_path = os.path.join(settings.upload_dir, file_path)
                                    if os.path.exists(full_path):
                                        extracted_text = extract_text_from_file(full_path)
                                        # Limit to first 2000 chars for context
                                        truncated_text = extracted_text[:2000]
                                        context_parts.append(
                                            f"Document: {doc_filename}\n{truncated_text}"
                                        )
                                    else:
                                        logger.warning(f"âš ï¸  File not found: {full_path}")
                                except Exception as extract_err:
                                    logger.warning(f"âš ï¸  Failed to extract text from {doc_filename}: {str(extract_err)}")
                            else:
                                logger.warning(f"âš ï¸  Document {doc_id} has no file path")
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch document {doc_id}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch document {doc_id}: {str(e)}")

        # Fallback to general context if no data fetched
        if not context_parts:
            logger.warning("âš ï¸  No context fetched, using general business scenarios")
            return "General business communication scenarios for professional practice."

        return "\n\n".join(context_parts)

    # NOTE: _generate_with_gpt ë©”ì„œë“œëŠ” agent/scenario/generator_agent.pyë¡œ ì´ë™ë¨

    async def create_manual(
        self,
        user_id: str,
        title: str,
        description: str,
        scenario_text: str,
        category: str,
        roles: Dict[str, str],
        required_terminology: List[str],
        language: str,
        difficulty: str,
        project_id: Optional[str] = None,
        schedule_id: Optional[str] = None,
        db: Session = None
    ) -> Dict[str, Any]:
        """
        Create a manual scenario.

        Args:
            user_id: User UUID
            title: Scenario title
            description: Brief description
            scenario_text: Detailed scenario text
            category: Scenario category
            roles: Role information dictionary
            required_terminology: List of required terms
            language: Target language
            difficulty: Difficulty level
            project_id: Optional project ID to associate with
            schedule_id: Optional schedule ID to associate with
            db: Database session

        Returns:
            Created scenario dictionary
        """
        logger.info(f"ğŸ“ Creating manual scenario: user={user_id}, title={title}, project={project_id}, schedule={schedule_id}")

        # Build project and schedule ID lists
        project_ids = [project_id] if project_id else []
        schedule_ids = [schedule_id] if schedule_id else []

        scenario = Scenario(
            user_id=user_id,
            title=title,
            description=description,
            scenario_text=scenario_text,
            language=language,
            difficulty=difficulty,
            category=category,
            roles=roles,
            required_terminology=required_terminology,
            project_ids=project_ids,
            schedule_ids=schedule_ids,
            auto_generated=False
        )

        db.add(scenario)
        db.commit()
        db.refresh(scenario)

        logger.info(f"âœ… Manual scenario created: {scenario.id}")

        return {
            "id": str(scenario.id),
            "title": scenario.title,
            "description": scenario.description,
            "scenarioText": scenario.scenario_text,
            "language": scenario.language,
            "difficulty": scenario.difficulty,
            "category": scenario.category,
            "roles": scenario.roles,
            "requiredTerminology": scenario.required_terminology,
            "projectIds": scenario.project_ids,
            "scheduleIds": scenario.schedule_ids,
            "autoGenerated": scenario.auto_generated,
            "createdAt": scenario.created_at.isoformat()
        }

    async def modify_with_chat(
        self,
        current_scenario: Dict[str, Any],
        user_message: str,
        language: str,
        difficulty: str
    ) -> Dict[str, Any]:
        """
        ì±„íŒ…ì„ í†µí•œ ì‹œë‚˜ë¦¬ì˜¤ ìˆ˜ì • (Agent íŒ¨í„´ ì‚¬ìš©)

        Args:
            current_scenario: í˜„ì¬ ì‹œë‚˜ë¦¬ì˜¤ ìƒíƒœ
            user_message: ì‚¬ìš©ìì˜ ìˆ˜ì • ìš”ì²­ ë©”ì‹œì§€
            language: ëª©í‘œ ì–¸ì–´
            difficulty: ë‚œì´ë„

        Returns:
            ìˆ˜ì •ëœ ì‹œë‚˜ë¦¬ì˜¤ í•„ë“œì™€ AI ì‘ë‹µ ë©”ì‹œì§€
        """
        return await self.modifier_agent.process(
            current_scenario=current_scenario,
            user_message=user_message,
            language=language,
            difficulty=difficulty
        )


"""
Scenario generation service with Agent pattern integration.
Generates conversation scenarios from projects and schedules.
"""
import logging
from typing import List, Dict, Any, Optional
import httpx

from sqlalchemy.orm import Session
from sqlalchemy import text

from app.models.scenario import Scenario
from agent.scenario.generator_agent import ScenarioGeneratorAgent
from agent.scenario.modifier_agent import ScenarioModifierAgent

logger = logging.getLogger(__name__)


class ScenarioService:
    """Service for generating and managing conversation scenarios."""

    def __init__(self):
        """Initialize with Agent pattern."""
        self.generator_agent = ScenarioGeneratorAgent()
        self.modifier_agent = ScenarioModifierAgent()

    async def generate_from_projects(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        language: str,
        difficulty: str,
        count: int,
        user_id: str,
        jwt_token: str,
        db: Session,
        save_to_db: bool = True,
        user_request: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios from projects and schedules using GPT-4o.

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            language: Target language (en, ko, zh, ja)
            difficulty: Difficulty level (beginner, intermediate, advanced)
            count: Number of scenarios to generate
            user_id: User UUID
            jwt_token: JWT token for Java API calls
            db: Database session
            save_to_db: Whether to save scenarios to DB (False for preview mode)
            user_request: User's specific request for scenario generation (optional)

        Returns:
            List of generated scenario dictionaries
        """
        # 1. Fetch context from Java backend and DB summaries
        context = await self._fetch_context(project_ids, schedule_ids, document_ids, jwt_token, db)

        # 2. Fetch glossary terms from project (if available)
        glossary_terms = await self._fetch_glossary_terms(project_ids, language, jwt_token)
        if glossary_terms:
            logger.info(f"[Glossary] Fetched {len(glossary_terms)} terms for language '{language}'")
        else:
            logger.info(f"[Glossary] No terms found, GPT will generate terminology")

        # 3. Generate scenarios with Agent pattern
        is_everyday = context == "General business communication scenarios for professional practice."
        scenarios_data = await self.generator_agent.process(
            context=context,
            language=language,
            difficulty=difficulty,
            count=count,
            is_everyday=is_everyday,
            user_request=user_request,
            glossary_terms=glossary_terms
        )

        # 3. Prepare response (and optionally save to PostgreSQL)
        result_scenarios = []
        for idx, scenario_data in enumerate(scenarios_data):
            try:
                if save_to_db:
                    # Save to DB mode
                    scenario = Scenario(
                        user_id=user_id,
                        title=scenario_data["title"],
                        description=scenario_data["description"],
                        scenario_text=scenario_data["scenarioText"],
                        language=language,
                        difficulty=difficulty,
                        category=scenario_data["category"],
                        roles=scenario_data["roles"],
                        required_terminology=scenario_data.get("requiredTerminology", []),
                        steps=scenario_data.get("steps", []),
                        project_ids=project_ids,
                        schedule_ids=schedule_ids,
                        document_ids=document_ids,
                        auto_generated=True
                    )
                    db.add(scenario)
                    db.flush()

                    result_scenarios.append({
                        "id": str(scenario.id),
                        "title": scenario.title,
                        "description": scenario.description,
                        "scenarioText": scenario.scenario_text,
                        "language": scenario.language,
                        "difficulty": scenario.difficulty,
                        "category": scenario.category,
                        "roles": scenario.roles,
                        "requiredTerminology": scenario.required_terminology,
                        "steps": scenario.steps,
                        "autoGenerated": scenario.auto_generated,
                        "createdAt": scenario.created_at.isoformat()
                    })

                else:
                    # Preview mode - don't save to DB
                    result_scenarios.append({
                        "title": scenario_data["title"],
                        "description": scenario_data["description"],
                        "scenarioText": scenario_data["scenarioText"],
                        "language": language,
                        "difficulty": difficulty,
                        "category": scenario_data["category"],
                        "roles": scenario_data["roles"],
                        "requiredTerminology": scenario_data.get("requiredTerminology", []),
                        "steps": scenario_data.get("steps", []),
                        "autoGenerated": True
                    })

            except Exception as e:
                logger.error(f"âŒ Failed to process scenario {idx + 1}: {str(e)}")
                continue

        if save_to_db:
            db.commit()

        return result_scenarios

    async def _fetch_context(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        jwt_token: str,
        db: Session
    ) -> str:
        """
        Fetch context from Java backend (projects, schedules) and DB (document summaries).

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            jwt_token: JWT token for authentication
            db: Database session for fetching document summaries

        Returns:
            Combined context string
        """
        headers = {"Authorization": f"Bearer {jwt_token}"}
        context_parts = []

        # Collect document IDs from projects (auto-fetch linked documents)
        all_document_ids = set(document_ids)  # Start with explicitly provided document IDs

        async with httpx.AsyncClient() as client:
            # Fetch project information
            for pid in project_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/projects/{pid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        response_data = response.json()
                        project = response_data.get('data', response_data)  # Handle ApiResponse wrapper
                        project_name = project.get('name', '')
                        project_desc = project.get('description', '')
                        context_parts.append(
                            f"Project: {project_name}\n"
                            f"Description: {project_desc}"
                        )
                        # Extract documentIds from project and add to fetch list
                        project_doc_ids = project.get('documentIds', [])
                        if project_doc_ids:
                            all_document_ids.update(project_doc_ids)
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch project {pid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch project {pid}: {str(e)}")

            # Fetch schedule information
            for sid in schedule_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/schedules/{sid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        schedule_data = response.json()
                        schedule = schedule_data.get('data', {})
                        schedule_title = schedule.get('title', '')
                        schedule_desc = schedule.get('description', '')
                        schedule_location = schedule.get('location', 'N/A')
                        context_parts.append(
                            f"Schedule: {schedule_title}\n"
                            f"Description: {schedule_desc}\n"
                            f"Location: {schedule_location}"
                        )
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: {str(e)}")

        # Fetch document summaries from DB (much faster than file extraction)
        for doc_id in all_document_ids:
            try:
                result = db.execute(
                    text("""
                        SELECT f.original_filename, df.summary
                        FROM document_files df
                        JOIN files f ON df.id = f.id
                        WHERE df.id = :doc_id AND df.summary IS NOT NULL
                    """),
                    {"doc_id": doc_id}
                ).fetchone()

                if result:
                    doc_filename, summary = result
                    context_parts.append(
                        f"Document: {doc_filename}\n"
                        f"Summary: {summary}"
                    )
                    logger.info(f"ğŸ“„ Using DB summary for document: {doc_filename}")
                else:
                    logger.warning(f"âš ï¸  No summary found for document {doc_id}")
            except Exception as e:
                logger.warning(f"âš ï¸  Failed to fetch document summary {doc_id}: {str(e)}")

        # Fallback to general context if no data fetched
        if not context_parts:
            logger.warning("âš ï¸  No context fetched, using general business scenarios")
            return "General business communication scenarios for professional practice."

        return "\n\n".join(context_parts)

    async def _fetch_glossary_terms(
        self,
        project_ids: List[str],
        language: str,
        jwt_token: str
    ) -> List[str]:
        """
        Fetch glossary terms from Java backend for the given projects.

        Args:
            project_ids: List of project UUIDs
            language: Target language code (en, ko, zh, ja, vi)
            jwt_token: JWT token for authentication

        Returns:
            List of glossary terms in the target language
        """
        if not project_ids:
            return []

        # Language field mapping
        lang_field_map = {
            "en": "englishTerm",
            "ko": "koreanTerm",
            "zh": "chineseTerm",
            "ja": "japaneseTerm",
            "vi": "vietnameseTerm"
        }
        term_field = lang_field_map.get(language, "englishTerm")

        headers = {"Authorization": f"Bearer {jwt_token}"}
        glossary_terms = []

        async with httpx.AsyncClient() as client:
            for project_id in project_ids:
                try:
                    # Fetch glossary terms for project (paginated, get first 100)
                    response = await client.get(
                        f"http://localhost:3000/api/glossary",
                        params={"projectId": project_id, "size": 100},
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        response_data = response.json()
                        data = response_data.get('data', {})
                        content = data.get('content', [])

                        for term in content:
                            # Get the term in target language
                            term_value = term.get(term_field)
                            if term_value:
                                glossary_terms.append(term_value)

                        logger.info(f"[Glossary] Fetched {len(content)} terms from project {project_id}")
                    else:
                        logger.warning(f"[Glossary] Failed to fetch for project {project_id}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"[Glossary] Failed to fetch for project {project_id}: {str(e)}")

        # Remove duplicates while preserving order
        seen = set()
        unique_terms = []
        for term in glossary_terms:
            if term not in seen:
                seen.add(term)
                unique_terms.append(term)

        return unique_terms

    # NOTE: _generate_with_gpt ë©”ì„œë“œëŠ” agent/scenario/generator_agent.pyë¡œ ì´ë™ë¨

    async def create_manual(
        self,
        user_id: str,
        title: str,
        description: str,
        scenario_text: str,
        category: str,
        roles: Dict[str, str],
        required_terminology: List[str],
        language: str,
        difficulty: str,
        project_id: Optional[str] = None,
        schedule_id: Optional[str] = None,
        steps: Optional[List[Dict[str, Any]]] = None,
        db: Session = None
    ) -> Dict[str, Any]:
        """
        Create a manual scenario.

        Args:
            user_id: User UUID
            title: Scenario title
            description: Brief description
            scenario_text: Detailed scenario text
            category: Scenario category
            roles: Role information dictionary
            required_terminology: List of required terms
            language: Target language
            difficulty: Difficulty level
            project_id: Optional project ID to associate with
            schedule_id: Optional schedule ID to associate with
            steps: Optional list of conversation steps
            db: Database session

        Returns:
            Created scenario dictionary
        """
        logger.info(f"Creating manual scenario: user={user_id}, title={title}, project={project_id}, schedule={schedule_id}")

        # Build project and schedule ID lists
        project_ids = [project_id] if project_id else []
        schedule_ids = [schedule_id] if schedule_id else []

        scenario = Scenario(
            user_id=user_id,
            title=title,
            description=description,
            scenario_text=scenario_text,
            language=language,
            difficulty=difficulty,
            category=category,
            roles=roles,
            required_terminology=required_terminology,
            steps=steps or [],
            project_ids=project_ids,
            schedule_ids=schedule_ids,
            auto_generated=False
        )

        db.add(scenario)
        db.commit()
        db.refresh(scenario)

        logger.info(f"Manual scenario created: {scenario.id}")

        return {
            "id": str(scenario.id),
            "title": scenario.title,
            "description": scenario.description,
            "scenarioText": scenario.scenario_text,
            "language": scenario.language,
            "difficulty": scenario.difficulty,
            "category": scenario.category,
            "roles": scenario.roles,
            "requiredTerminology": scenario.required_terminology,
            "steps": scenario.steps,
            "projectIds": scenario.project_ids,
            "scheduleIds": scenario.schedule_ids,
            "autoGenerated": scenario.auto_generated,
            "createdAt": scenario.created_at.isoformat()
        }

    async def modify_with_chat(
        self,
        current_scenario: Dict[str, Any],
        user_message: str,
        language: str,
        difficulty: str
    ) -> Dict[str, Any]:
        """
        ì±„íŒ…ì„ í†µí•œ ì‹œë‚˜ë¦¬ì˜¤ ìˆ˜ì • (Agent íŒ¨í„´ ì‚¬ìš©)

        Args:
            current_scenario: í˜„ì¬ ì‹œë‚˜ë¦¬ì˜¤ ìƒíƒœ
            user_message: ì‚¬ìš©ìì˜ ìˆ˜ì • ìš”ì²­ ë©”ì‹œì§€
            language: ëª©í‘œ ì–¸ì–´
            difficulty: ë‚œì´ë„

        Returns:
            ìˆ˜ì •ëœ ì‹œë‚˜ë¦¬ì˜¤ í•„ë“œì™€ AI ì‘ë‹µ ë©”ì‹œì§€
        """
        return await self.modifier_agent.process(
            current_scenario=current_scenario,
            user_message=user_message,
            language=language,
            difficulty=difficulty
        )


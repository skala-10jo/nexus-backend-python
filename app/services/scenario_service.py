"""
Scenario generation service with Agent pattern integration.
Generates conversation scenarios from projects and schedules.
"""
import logging
from typing import List, Dict, Any, Optional
import httpx

from app.config import settings
from app.models.scenario import Scenario
from sqlalchemy.orm import Session

from agent.scenario.generator_agent import ScenarioGeneratorAgent
from agent.scenario.modifier_agent import ScenarioModifierAgent

logger = logging.getLogger(__name__)


class ScenarioService:
    """Service for generating and managing conversation scenarios."""

    def __init__(self):
        """Initialize with Agent pattern."""
        self.generator_agent = ScenarioGeneratorAgent()
        self.modifier_agent = ScenarioModifierAgent()

    async def generate_from_projects(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        language: str,
        difficulty: str,
        count: int,
        user_id: str,
        jwt_token: str,
        db: Session,
        save_to_db: bool = True
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios from projects and schedules using GPT-4o.

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            language: Target language (en, ko, zh, ja)
            difficulty: Difficulty level (beginner, intermediate, advanced)
            count: Number of scenarios to generate
            user_id: User UUID
            jwt_token: JWT token for Java API calls
            db: Database session
            save_to_db: Whether to save scenarios to DB (False for preview mode)

        Returns:
            List of generated scenario dictionaries
        """
        logger.info(f"ğŸš€ Starting scenario generation: user={user_id}, projects={len(project_ids)}, schedules={len(schedule_ids)}, documents={len(document_ids)}")

        # 1. Fetch context from Java backend
        context = await self._fetch_context(project_ids, schedule_ids, document_ids, jwt_token)
        logger.info(f"ğŸ“ Context fetched: {len(context)} characters")

        # 2. Generate scenarios with Agent pattern
        is_everyday = context == "General business communication scenarios for professional practice."
        scenarios_data = await self.generator_agent.process(
            context=context,
            language=language,
            difficulty=difficulty,
            count=count,
            is_everyday=is_everyday
        )
        logger.info(f"ğŸ¤– Agent generated {len(scenarios_data)} scenarios")

        # 3. Prepare response (and optionally save to PostgreSQL)
        result_scenarios = []
        for idx, scenario_data in enumerate(scenarios_data):
            try:
                if save_to_db:
                    # Save to DB mode
                    scenario = Scenario(
                        user_id=user_id,
                        title=scenario_data["title"],
                        description=scenario_data["description"],
                        scenario_text=scenario_data["scenarioText"],
                        language=language,
                        difficulty=difficulty,
                        category=scenario_data["category"],
                        roles=scenario_data["roles"],
                        required_terminology=scenario_data.get("requiredTerminology", []),
                        project_ids=project_ids,
                        schedule_ids=schedule_ids,
                        document_ids=document_ids,
                        auto_generated=True
                    )
                    db.add(scenario)
                    db.flush()

                    result_scenarios.append({
                        "id": str(scenario.id),
                        "title": scenario.title,
                        "description": scenario.description,
                        "scenarioText": scenario.scenario_text,
                        "language": scenario.language,
                        "difficulty": scenario.difficulty,
                        "category": scenario.category,
                        "roles": scenario.roles,
                        "requiredTerminology": scenario.required_terminology,
                        "autoGenerated": scenario.auto_generated,
                        "createdAt": scenario.created_at.isoformat()
                    })

                    logger.info(f"ğŸ’¾ Saved scenario {idx + 1}/{len(scenarios_data)}: {scenario.title}")
                else:
                    # Preview mode - don't save to DB
                    result_scenarios.append({
                        "title": scenario_data["title"],
                        "description": scenario_data["description"],
                        "scenarioText": scenario_data["scenarioText"],
                        "language": language,
                        "difficulty": difficulty,
                        "category": scenario_data["category"],
                        "roles": scenario_data["roles"],
                        "requiredTerminology": scenario_data.get("requiredTerminology", []),
                        "autoGenerated": True
                    })

                    logger.info(f"ğŸ“‹ Generated preview scenario {idx + 1}/{len(scenarios_data)}: {scenario_data['title']}")

            except Exception as e:
                logger.error(f"âŒ Failed to process scenario {idx + 1}: {str(e)}")
                continue

        if save_to_db:
            db.commit()
            logger.info(f"âœ… Successfully saved {len(result_scenarios)}/{len(scenarios_data)} scenarios")
        else:
            logger.info(f"âœ… Generated {len(result_scenarios)} preview scenarios (not saved to DB)")

        return result_scenarios

    async def _fetch_context(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        jwt_token: str
    ) -> str:
        """
        Fetch context from Java backend (projects, schedules, and documents).

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            jwt_token: JWT token for authentication

        Returns:
            Combined context string
        """
        headers = {"Authorization": f"Bearer {jwt_token}"}
        context_parts = []

        async with httpx.AsyncClient() as client:
            # Fetch project information
            for pid in project_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/projects/{pid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        project = response.json()
                        context_parts.append(
                            f"Project: {project.get('name', '')}\n"
                            f"Description: {project.get('description', '')}"
                        )
                        logger.info(f"âœ… Fetched project: {project.get('name', '')}")
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch project {pid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch project {pid}: {str(e)}")

            # Fetch schedule information
            for sid in schedule_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/schedules/{sid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        schedule_data = response.json()
                        schedule = schedule_data.get('data', {})
                        context_parts.append(
                            f"Schedule: {schedule.get('title', '')}\n"
                            f"Description: {schedule.get('description', '')}\n"
                            f"Location: {schedule.get('location', 'N/A')}"
                        )
                        logger.info(f"âœ… Fetched schedule: {schedule.get('title', '')}")
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch schedule {sid}: {str(e)}")

            # Fetch document contents
            for doc_id in document_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/documents/{doc_id}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        doc_data = response.json()
                        document = doc_data.get('data', {})

                        # Extract page contents (limit to first 5 pages, 500 chars per page)
                        contents = document.get('contents', [])[:5]
                        if contents:
                            text_parts = []
                            for content in contents:
                                page_text = content.get('content', '')[:500]
                                if page_text:
                                    text_parts.append(f"Page {content.get('pageNumber', '?')}: {page_text}")

                            if text_parts:
                                context_parts.append(
                                    f"Document: {document.get('originalFilename', '')}\n"
                                    + "\n".join(text_parts)
                                )
                                logger.info(f"âœ… Fetched document: {document.get('originalFilename', '')} ({len(contents)} pages)")
                        else:
                            logger.warning(f"âš ï¸  Document {doc_id} has no content")
                    else:
                        logger.warning(f"âš ï¸  Failed to fetch document {doc_id}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"âš ï¸  Failed to fetch document {doc_id}: {str(e)}")

        # Fallback to general context if no data fetched
        if not context_parts:
            logger.warning("âš ï¸  No context fetched, using general business scenarios")
            return "General business communication scenarios for professional practice."

        return "\n\n".join(context_parts)

    # NOTE: _generate_with_gpt ë©”ì„œë“œëŠ” agent/scenario/generator_agent.pyë¡œ ì´ë™ë¨

    async def create_manual(
        self,
        user_id: str,
        title: str,
        description: str,
        scenario_text: str,
        category: str,
        roles: Dict[str, str],
        required_terminology: List[str],
        language: str,
        difficulty: str,
        project_id: Optional[str] = None,
        schedule_id: Optional[str] = None,
        db: Session = None
    ) -> Dict[str, Any]:
        """
        Create a manual scenario.

        Args:
            user_id: User UUID
            title: Scenario title
            description: Brief description
            scenario_text: Detailed scenario text
            category: Scenario category
            roles: Role information dictionary
            required_terminology: List of required terms
            language: Target language
            difficulty: Difficulty level
            project_id: Optional project ID to associate with
            schedule_id: Optional schedule ID to associate with
            db: Database session

        Returns:
            Created scenario dictionary
        """
        logger.info(f"ğŸ“ Creating manual scenario: user={user_id}, title={title}, project={project_id}, schedule={schedule_id}")

        # Build project and schedule ID lists
        project_ids = [project_id] if project_id else []
        schedule_ids = [schedule_id] if schedule_id else []

        scenario = Scenario(
            user_id=user_id,
            title=title,
            description=description,
            scenario_text=scenario_text,
            language=language,
            difficulty=difficulty,
            category=category,
            roles=roles,
            required_terminology=required_terminology,
            project_ids=project_ids,
            schedule_ids=schedule_ids,
            auto_generated=False
        )

        db.add(scenario)
        db.commit()
        db.refresh(scenario)

        logger.info(f"âœ… Manual scenario created: {scenario.id}")

        return {
            "id": str(scenario.id),
            "title": scenario.title,
            "description": scenario.description,
            "scenarioText": scenario.scenario_text,
            "language": scenario.language,
            "difficulty": scenario.difficulty,
            "category": scenario.category,
            "roles": scenario.roles,
            "requiredTerminology": scenario.required_terminology,
            "projectIds": scenario.project_ids,
            "scheduleIds": scenario.schedule_ids,
            "autoGenerated": scenario.auto_generated,
            "createdAt": scenario.created_at.isoformat()
        }

    async def modify_with_chat(
        self,
        current_scenario: Dict[str, Any],
        user_message: str,
        language: str,
        difficulty: str
    ) -> Dict[str, Any]:
        """
        ì±„íŒ…ì„ í†µí•œ ì‹œë‚˜ë¦¬ì˜¤ ìˆ˜ì • (Agent íŒ¨í„´ ì‚¬ìš©)

        Args:
            current_scenario: í˜„ì¬ ì‹œë‚˜ë¦¬ì˜¤ ìƒíƒœ
            user_message: ì‚¬ìš©ìì˜ ìˆ˜ì • ìš”ì²­ ë©”ì‹œì§€
            language: ëª©í‘œ ì–¸ì–´
            difficulty: ë‚œì´ë„

        Returns:
            ìˆ˜ì •ëœ ì‹œë‚˜ë¦¬ì˜¤ í•„ë“œì™€ AI ì‘ë‹µ ë©”ì‹œì§€
        """
        return await self.modifier_agent.process(
            current_scenario=current_scenario,
            user_message=user_message,
            language=language,
            difficulty=difficulty
        )


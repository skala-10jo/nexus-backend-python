"""
Scenario generation service with OpenAI GPT-4o integration.
Generates conversation scenarios from projects and schedules.
"""
import logging
from typing import List, Dict, Any
from openai import AsyncOpenAI
import httpx
import json

from app.config import settings
from app.models.scenario import Scenario
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


class ScenarioService:
    """Service for generating and managing conversation scenarios."""

    def __init__(self):
        """Initialize OpenAI client."""
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)

    async def generate_from_projects(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        language: str,
        difficulty: str,
        count: int,
        user_id: str,
        jwt_token: str,
        db: Session
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios from projects and schedules using GPT-4o.

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            language: Target language (en, ko, zh, ja)
            difficulty: Difficulty level (beginner, intermediate, advanced)
            count: Number of scenarios to generate
            user_id: User UUID
            jwt_token: JWT token for Java API calls
            db: Database session

        Returns:
            List of generated scenario dictionaries
        """
        logger.info(f"üöÄ Starting scenario generation: user={user_id}, projects={len(project_ids)}, schedules={len(schedule_ids)}, documents={len(document_ids)}")

        # 1. Fetch context from Java backend
        context = await self._fetch_context(project_ids, schedule_ids, document_ids, jwt_token)
        logger.info(f"üìù Context fetched: {len(context)} characters")

        # 2. Generate scenarios with GPT-4o
        scenarios_data = await self._generate_with_gpt(context, language, difficulty, count)
        logger.info(f"ü§ñ GPT-4o generated {len(scenarios_data)} scenarios")

        # 3. Save to PostgreSQL
        saved_scenarios = []
        for idx, scenario_data in enumerate(scenarios_data):
            try:
                scenario = Scenario(
                    user_id=user_id,
                    title=scenario_data["title"],
                    description=scenario_data["description"],
                    scenario_text=scenario_data["scenarioText"],
                    language=language,
                    difficulty=difficulty,
                    category=scenario_data["category"],
                    roles=scenario_data["roles"],
                    required_terminology=scenario_data.get("requiredTerminology", []),
                    project_ids=project_ids,
                    schedule_ids=schedule_ids,
                    document_ids=document_ids,
                    auto_generated=True
                )
                db.add(scenario)
                db.flush()

                saved_scenarios.append({
                    "id": str(scenario.id),
                    "title": scenario.title,
                    "description": scenario.description,
                    "scenarioText": scenario.scenario_text,
                    "language": scenario.language,
                    "difficulty": scenario.difficulty,
                    "category": scenario.category,
                    "roles": scenario.roles,
                    "requiredTerminology": scenario.required_terminology,
                    "autoGenerated": scenario.auto_generated,
                    "createdAt": scenario.created_at.isoformat()
                })

                logger.info(f"üíæ Saved scenario {idx + 1}/{len(scenarios_data)}: {scenario.title}")

            except Exception as e:
                logger.error(f"‚ùå Failed to save scenario {idx + 1}: {str(e)}")
                continue

        db.commit()
        logger.info(f"‚úÖ Successfully saved {len(saved_scenarios)}/{len(scenarios_data)} scenarios")

        return saved_scenarios

    async def _fetch_context(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        jwt_token: str
    ) -> str:
        """
        Fetch context from Java backend (projects, schedules, and documents).

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            jwt_token: JWT token for authentication

        Returns:
            Combined context string
        """
        headers = {"Authorization": f"Bearer {jwt_token}"}
        context_parts = []

        async with httpx.AsyncClient() as client:
            # Fetch project information
            for pid in project_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/projects/{pid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        project = response.json()
                        context_parts.append(
                            f"Project: {project.get('name', '')}\n"
                            f"Description: {project.get('description', '')}"
                        )
                        logger.info(f"‚úÖ Fetched project: {project.get('name', '')}")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch project {pid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch project {pid}: {str(e)}")

            # Fetch schedule information
            for sid in schedule_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/schedules/{sid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        schedule_data = response.json()
                        schedule = schedule_data.get('data', {})
                        context_parts.append(
                            f"Schedule: {schedule.get('title', '')}\n"
                            f"Description: {schedule.get('description', '')}\n"
                            f"Location: {schedule.get('location', 'N/A')}"
                        )
                        logger.info(f"‚úÖ Fetched schedule: {schedule.get('title', '')}")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch schedule {sid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch schedule {sid}: {str(e)}")

            # Fetch document contents
            for doc_id in document_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/documents/{doc_id}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        doc_data = response.json()
                        document = doc_data.get('data', {})

                        # Extract page contents (limit to first 5 pages, 500 chars per page)
                        contents = document.get('contents', [])[:5]
                        if contents:
                            text_parts = []
                            for content in contents:
                                page_text = content.get('content', '')[:500]
                                if page_text:
                                    text_parts.append(f"Page {content.get('pageNumber', '?')}: {page_text}")

                            if text_parts:
                                context_parts.append(
                                    f"Document: {document.get('originalFilename', '')}\n"
                                    + "\n".join(text_parts)
                                )
                                logger.info(f"‚úÖ Fetched document: {document.get('originalFilename', '')} ({len(contents)} pages)")
                        else:
                            logger.warning(f"‚ö†Ô∏è  Document {doc_id} has no content")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch document {doc_id}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch document {doc_id}: {str(e)}")

        # Fallback to general context if no data fetched
        if not context_parts:
            logger.warning("‚ö†Ô∏è  No context fetched, using general business scenarios")
            return "General business communication scenarios for professional practice."

        return "\n\n".join(context_parts)

    async def _generate_with_gpt(
        self,
        context: str,
        language: str,
        difficulty: str,
        count: int
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios using GPT-4o.

        Args:
            context: Context from projects/schedules
            language: Target language
            difficulty: Difficulty level
            count: Number of scenarios to generate

        Returns:
            List of scenario dictionaries
        """
        # Language mapping
        lang_map = {
            "en": "English",
            "ko": "Korean (ÌïúÍµ≠Ïñ¥)",
            "zh": "Chinese (‰∏≠Êñá)",
            "ja": "Japanese (Êó•Êú¨Ë™û)"
        }
        target_lang = lang_map.get(language, "English")

        # Prepare prompt
        prompt = f"""Îã§Ïùå Ïª®ÌÖçÏä§Ìä∏Î•º Î∞îÌÉïÏúºÎ°ú {target_lang}Î°ú Îêú ÌòÑÏã§Ï†ÅÏù∏ ÎπÑÏ¶àÎãàÏä§ ÎåÄÌôî ÏãúÎÇòÎ¶¨Ïò§ {count}Í∞úÎ•º ÏÉùÏÑ±Ìï¥Ï§ò.

Ïª®ÌÖçÏä§Ìä∏:
{context[:3000]}

ÏöîÍµ¨ÏÇ¨Ìï≠:
- ÎÇúÏù¥ÎèÑ: {difficulty}
- Î™©Ìëú Ïñ∏Ïñ¥: {target_lang}
- Í∞Å ÏãúÎÇòÎ¶¨Ïò§Îäî ÌòÑÏã§Ï†ÅÏù∏ ÎπÑÏ¶àÎãàÏä§ ÏÉÅÌô©ÏùÑ Î∞òÏòÅÌï¥Ïïº Ìï®
- Ïª®ÌÖçÏä§Ìä∏ÏóêÏÑú 3-5Í∞úÏùò ÌïµÏã¨ Í∏∞Ïà† Ïö©Ïñ¥ ÏãùÎ≥Ñ
- Îã§ÏñëÌïú ÏãúÎÇòÎ¶¨Ïò§ Ïú†Ìòï ÏÉùÏÑ±: ÌòëÏóÖ, Í∏∞Ïà† ÏßÄÏõê, Ï†úÌíà ÏÑ§Î™Ö, Î¨∏Ï†ú Ìï¥Í≤∞
- Ï†úÎ™©Í≥º ÏÑ§Î™ÖÏùÄ Î™©Ìëú Ïñ∏Ïñ¥ÏôÄ Í¥ÄÍ≥ÑÏóÜÏù¥ Î∞òÎìúÏãú ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä)Î°ú ÏûëÏÑ±
- Ïó≠Ìï† ÏÑ§Î™ÖÏùÄ Í∞ÑÎã®ÌïòÍ≥† Î™ÖÎ£åÌïòÍ≤å (1-2 Îã®Ïñ¥)

Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏãúÎÇòÎ¶¨Ïò§Î•º ÏÉùÏÑ±Ìï¥Ï§ò:
{{
  "scenarios": [
    {{
      "title": "ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä) ÏãúÎÇòÎ¶¨Ïò§ Ï†úÎ™©",
      "description": "ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä)Î°ú Îêú Í∞ÑÎã®Ìïú ÏÑ§Î™Ö (2-3 Î¨∏Ïû•)",
      "scenarioText": "{target_lang}Î°ú Îêú ÏÉÅÏÑ∏ ÏãúÎÇòÎ¶¨Ïò§ ÏÑ§Î™Ö (5-7 Î¨∏Ïû•). ÏÉÅÌô©, Îß•ÎùΩ, Î™©ÌëúÎ•º ÏÑ§Î™Ö",
      "category": "Collaboration|Technical Support|Product Explanation|Problem Solving",
      "roles": {{
        "user": "{target_lang}Î°ú Îêú Í∞ÑÎã®Ìïú ÏÇ¨Ïö©Ïûê Ïó≠Ìï† (1-2 Îã®Ïñ¥)",
        "ai": "{target_lang}Î°ú Îêú Í∞ÑÎã®Ìïú ÏÉÅÎåÄÎ∞© Ïó≠Ìï† (1-2 Îã®Ïñ¥)"
      }},
      "requiredTerminology": ["Ïö©Ïñ¥1", "Ïö©Ïñ¥2", "Ïö©Ïñ¥3"]
    }}
  ]
}}

Ï§ëÏöî:
- title: Ìï≠ÏÉÅ ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä)
- description: Ìï≠ÏÉÅ ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä)
- scenarioText: {target_lang}Î°ú ÏûëÏÑ±
- roles.user: {target_lang}Î°ú Îêú Í∞ÑÎã®Ìïú 1-2 Îã®Ïñ¥ Ïó≠Ìï† ÏÑ§Î™Ö (Ïòà: "Project Manager", "Developer")
- roles.ai: {target_lang}Î°ú Îêú Í∞ÑÎã®Ìïú 1-2 Îã®Ïñ¥ ÏÉÅÎåÄÎ∞© Ïó≠Ìï† (Ïòà: "Client", "Team Lead", "Colleague") - "AI"ÎÇò "Assistant" ÏÇ¨Ïö© Í∏àÏßÄ

"scenarios" Î∞∞Ïó¥Ïóê Ï†ïÌôïÌûà {count}Í∞úÏùò ÏãúÎÇòÎ¶¨Ïò§Î•º ÏÉùÏÑ±Ìï¥Ï§ò."""

        # Call GPT-4o
        logger.info(f"ü§ñ Calling GPT-4o for scenario generation (language={language}, difficulty={difficulty}, count={count})")

        response = await self.client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": f"ÎãπÏã†ÏùÄ ÌòÑÏã§Ï†ÅÏù∏ ÎπÑÏ¶àÎãàÏä§ ÎåÄÌôî ÏãúÎÇòÎ¶¨Ïò§Î•º ÎßåÎìúÎäî Ï†ÑÎ¨∏Í∞ÄÏù¥Îã§. Ïñ∏Ïñ¥ Ïó∞ÏäµÏóê Ï†ÅÌï©Ìïú Ïûò Íµ¨Ï°∞ÌôîÎêú ÏãúÎÇòÎ¶¨Ïò§Î•º {target_lang}Î°ú ÏÉùÏÑ±ÌïúÎã§. Ï†úÎ™©Í≥º ÏÑ§Î™ÖÏùÄ Ìï≠ÏÉÅ ÌïúÍµ≠Ïñ¥(ÌïúÍ∏Ä)Î°ú ÏûëÏÑ±ÌïòÎ©∞, Ïó≠Ìï† ÏÑ§Î™ÖÏùÄ Í∞ÑÎã®ÌïòÍ≤å(1-2 Îã®Ïñ¥) Ïú†ÏßÄÌïúÎã§. 'ai' Ïó≠Ìï†Ïùò Í≤ΩÏö∞ 'Client', 'Team Lead', 'Colleague' Îì±Í≥º Í∞ôÏùÄ ÌòÑÏã§Ï†ÅÏù∏ ÏÉÅÎåÄÎ∞© Ïó≠Ìï†ÏùÑ ÏÇ¨Ïö©ÌïòÎ©∞, Ï†àÎåÄ 'AI'ÎÇò 'Assistant'Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäîÎã§."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            response_format={"type": "json_object"},
            temperature=0.8
        )

        # Parse response
        result = json.loads(response.choices[0].message.content)
        scenarios = result.get("scenarios", [])

        if not scenarios:
            logger.error("‚ùå GPT-4o returned no scenarios")
            raise ValueError("Failed to generate scenarios from GPT-4o")

        logger.info(f"‚úÖ GPT-4o returned {len(scenarios)} scenarios")
        return scenarios

    async def create_manual(
        self,
        user_id: str,
        title: str,
        description: str,
        scenario_text: str,
        category: str,
        roles: Dict[str, str],
        required_terminology: List[str],
        language: str,
        difficulty: str,
        db: Session
    ) -> Dict[str, Any]:
        """
        Create a manual scenario.

        Args:
            user_id: User UUID
            title: Scenario title
            description: Brief description
            scenario_text: Detailed scenario text
            category: Scenario category
            roles: Role information dictionary
            required_terminology: List of required terms
            language: Target language
            difficulty: Difficulty level
            db: Database session

        Returns:
            Created scenario dictionary
        """
        logger.info(f"üìù Creating manual scenario: user={user_id}, title={title}")

        scenario = Scenario(
            user_id=user_id,
            title=title,
            description=description,
            scenario_text=scenario_text,
            language=language,
            difficulty=difficulty,
            category=category,
            roles=roles,
            required_terminology=required_terminology,
            project_ids=[],
            schedule_ids=[],
            auto_generated=False
        )

        db.add(scenario)
        db.commit()
        db.refresh(scenario)

        logger.info(f"‚úÖ Manual scenario created: {scenario.id}")

        return {
            "id": str(scenario.id),
            "title": scenario.title,
            "description": scenario.description,
            "scenarioText": scenario.scenario_text,
            "language": scenario.language,
            "difficulty": scenario.difficulty,
            "category": scenario.category,
            "roles": scenario.roles,
            "requiredTerminology": scenario.required_terminology,
            "autoGenerated": scenario.auto_generated,
            "createdAt": scenario.created_at.isoformat()
        }

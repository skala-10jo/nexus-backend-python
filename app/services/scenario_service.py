"""
Scenario generation service with OpenAI GPT-4o integration.
Generates conversation scenarios from projects and schedules.
"""
import logging
from typing import List, Dict, Any
from openai import AsyncOpenAI
import httpx
import json

from app.config import settings
from app.models.scenario import Scenario
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


class ScenarioService:
    """Service for generating and managing conversation scenarios."""

    def __init__(self):
        """Initialize OpenAI client."""
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)

    async def generate_from_projects(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        language: str,
        difficulty: str,
        count: int,
        user_id: str,
        jwt_token: str,
        db: Session
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios from projects and schedules using GPT-4o.

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            language: Target language (en, ko, zh, ja)
            difficulty: Difficulty level (beginner, intermediate, advanced)
            count: Number of scenarios to generate
            user_id: User UUID
            jwt_token: JWT token for Java API calls
            db: Database session

        Returns:
            List of generated scenario dictionaries
        """
        logger.info(f"üöÄ Starting scenario generation: user={user_id}, projects={len(project_ids)}, schedules={len(schedule_ids)}, documents={len(document_ids)}")

        # 1. Fetch context from Java backend
        context = await self._fetch_context(project_ids, schedule_ids, document_ids, jwt_token)
        logger.info(f"üìù Context fetched: {len(context)} characters")

        # 2. Generate scenarios with GPT-4o
        scenarios_data = await self._generate_with_gpt(context, language, difficulty, count)
        logger.info(f"ü§ñ GPT-4o generated {len(scenarios_data)} scenarios")

        # 3. Save to PostgreSQL
        saved_scenarios = []
        for idx, scenario_data in enumerate(scenarios_data):
            try:
                scenario = Scenario(
                    user_id=user_id,
                    title=scenario_data["title"],
                    description=scenario_data["description"],
                    scenario_text=scenario_data["scenarioText"],
                    language=language,
                    difficulty=difficulty,
                    category=scenario_data["category"],
                    roles=scenario_data["roles"],
                    required_terminology=scenario_data.get("requiredTerminology", []),
                    project_ids=project_ids,
                    schedule_ids=schedule_ids,
                    document_ids=document_ids,
                    auto_generated=True
                )
                db.add(scenario)
                db.flush()

                saved_scenarios.append({
                    "id": str(scenario.id),
                    "title": scenario.title,
                    "description": scenario.description,
                    "scenarioText": scenario.scenario_text,
                    "language": scenario.language,
                    "difficulty": scenario.difficulty,
                    "category": scenario.category,
                    "roles": scenario.roles,
                    "requiredTerminology": scenario.required_terminology,
                    "autoGenerated": scenario.auto_generated,
                    "createdAt": scenario.created_at.isoformat()
                })

                logger.info(f"üíæ Saved scenario {idx + 1}/{len(scenarios_data)}: {scenario.title}")

            except Exception as e:
                logger.error(f"‚ùå Failed to save scenario {idx + 1}: {str(e)}")
                continue

        db.commit()
        logger.info(f"‚úÖ Successfully saved {len(saved_scenarios)}/{len(scenarios_data)} scenarios")

        return saved_scenarios

    async def _fetch_context(
        self,
        project_ids: List[str],
        schedule_ids: List[str],
        document_ids: List[str],
        jwt_token: str
    ) -> str:
        """
        Fetch context from Java backend (projects, schedules, and documents).

        Args:
            project_ids: List of project UUIDs
            schedule_ids: List of schedule UUIDs
            document_ids: List of document UUIDs
            jwt_token: JWT token for authentication

        Returns:
            Combined context string
        """
        headers = {"Authorization": f"Bearer {jwt_token}"}
        context_parts = []

        async with httpx.AsyncClient() as client:
            # Fetch project information
            for pid in project_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/projects/{pid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        project = response.json()
                        context_parts.append(
                            f"Project: {project.get('name', '')}\n"
                            f"Description: {project.get('description', '')}"
                        )
                        logger.info(f"‚úÖ Fetched project: {project.get('name', '')}")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch project {pid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch project {pid}: {str(e)}")

            # Fetch schedule information
            for sid in schedule_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/schedules/{sid}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        schedule_data = response.json()
                        schedule = schedule_data.get('data', {})
                        context_parts.append(
                            f"Schedule: {schedule.get('title', '')}\n"
                            f"Description: {schedule.get('description', '')}\n"
                            f"Location: {schedule.get('location', 'N/A')}"
                        )
                        logger.info(f"‚úÖ Fetched schedule: {schedule.get('title', '')}")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch schedule {sid}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch schedule {sid}: {str(e)}")

            # Fetch document contents
            for doc_id in document_ids:
                try:
                    response = await client.get(
                        f"http://localhost:3000/api/documents/{doc_id}",
                        headers=headers,
                        timeout=10.0
                    )
                    if response.status_code == 200:
                        doc_data = response.json()
                        document = doc_data.get('data', {})

                        # Extract page contents (limit to first 5 pages, 500 chars per page)
                        contents = document.get('contents', [])[:5]
                        if contents:
                            text_parts = []
                            for content in contents:
                                page_text = content.get('content', '')[:500]
                                if page_text:
                                    text_parts.append(f"Page {content.get('pageNumber', '?')}: {page_text}")

                            if text_parts:
                                context_parts.append(
                                    f"Document: {document.get('originalFilename', '')}\n"
                                    + "\n".join(text_parts)
                                )
                                logger.info(f"‚úÖ Fetched document: {document.get('originalFilename', '')} ({len(contents)} pages)")
                        else:
                            logger.warning(f"‚ö†Ô∏è  Document {doc_id} has no content")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Failed to fetch document {doc_id}: status {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Failed to fetch document {doc_id}: {str(e)}")

        # Fallback to general context if no data fetched
        if not context_parts:
            logger.warning("‚ö†Ô∏è  No context fetched, using general business scenarios")
            return "General business communication scenarios for professional practice."

        return "\n\n".join(context_parts)

    async def _generate_with_gpt(
        self,
        context: str,
        language: str,
        difficulty: str,
        count: int
    ) -> List[Dict[str, Any]]:
        """
        Generate scenarios using GPT-4o.

        Args:
            context: Context from projects/schedules
            language: Target language
            difficulty: Difficulty level
            count: Number of scenarios to generate

        Returns:
            List of scenario dictionaries
        """
        # Language mapping
        lang_map = {
            "en": "English",
            "ko": "Korean (ÌïúÍµ≠Ïñ¥)",
            "zh": "Chinese (‰∏≠Êñá)",
            "ja": "Japanese (Êó•Êú¨Ë™û)"
        }
        target_lang = lang_map.get(language, "English")

        # Prepare prompt
        prompt = f"""Based on the following context, generate {count} realistic business conversation scenarios in {target_lang}.

Context:
{context[:3000]}

Requirements:
- Difficulty level: {difficulty}
- Target language: {target_lang}
- Each scenario should represent realistic business situations
- Identify 3-5 key technical terms from the context
- Create diverse scenario types: Collaboration, Technical Support, Product Explanation, Problem Solving
- Title and description MUST be in Korean (ÌïúÍ∏Ä) regardless of target language
- Role descriptions should be simple and concise (1-2 words)

Generate scenarios in the following JSON format:
{{
  "scenarios": [
    {{
      "title": "Scenario title in Korean (ÌïúÍ∏Ä)",
      "description": "Brief description (2-3 sentences) in Korean (ÌïúÍ∏Ä)",
      "scenarioText": "Detailed scenario description (5-7 sentences) explaining situation, context, and objectives in {target_lang}",
      "category": "Collaboration|Technical Support|Product Explanation|Problem Solving",
      "roles": {{
        "user": "Simple user role (1-2 words in {target_lang})",
        "ai": "Simple counterpart role (1-2 words in {target_lang})"
      }},
      "requiredTerminology": ["term1", "term2", "term3"]
    }}
  ]
}}

IMPORTANT:
- title: ALWAYS in Korean (ÌïúÍ∏Ä)
- description: ALWAYS in Korean (ÌïúÍ∏Ä)
- scenarioText: In {target_lang}
- roles.user: Simple 1-2 word role description in {target_lang} (e.g., "Project Manager", "Developer")
- roles.ai: Simple 1-2 word counterpart role in {target_lang} (e.g., "Client", "Team Lead", "Colleague") - NOT "AI" or "Assistant"

Generate exactly {count} scenarios in the "scenarios" array."""

        # Call GPT-4o
        logger.info(f"ü§ñ Calling GPT-4o for scenario generation (language={language}, difficulty={difficulty}, count={count})")

        response = await self.client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": f"You are an expert at creating realistic business conversation scenarios. You generate well-structured scenarios in {target_lang} suitable for language practice. You ALWAYS write titles and descriptions in Korean (ÌïúÍ∏Ä), and keep role descriptions simple (1-2 words). For the 'ai' role, use realistic counterpart roles like 'Client', 'Team Lead', 'Colleague', etc. - NEVER use 'AI' or 'Assistant'."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            response_format={"type": "json_object"},
            temperature=0.8
        )

        # Parse response
        result = json.loads(response.choices[0].message.content)
        scenarios = result.get("scenarios", [])

        if not scenarios:
            logger.error("‚ùå GPT-4o returned no scenarios")
            raise ValueError("Failed to generate scenarios from GPT-4o")

        logger.info(f"‚úÖ GPT-4o returned {len(scenarios)} scenarios")
        return scenarios

    async def create_manual(
        self,
        user_id: str,
        title: str,
        description: str,
        scenario_text: str,
        category: str,
        roles: Dict[str, str],
        required_terminology: List[str],
        language: str,
        difficulty: str,
        db: Session
    ) -> Dict[str, Any]:
        """
        Create a manual scenario.

        Args:
            user_id: User UUID
            title: Scenario title
            description: Brief description
            scenario_text: Detailed scenario text
            category: Scenario category
            roles: Role information dictionary
            required_terminology: List of required terms
            language: Target language
            difficulty: Difficulty level
            db: Database session

        Returns:
            Created scenario dictionary
        """
        logger.info(f"üìù Creating manual scenario: user={user_id}, title={title}")

        scenario = Scenario(
            user_id=user_id,
            title=title,
            description=description,
            scenario_text=scenario_text,
            language=language,
            difficulty=difficulty,
            category=category,
            roles=roles,
            required_terminology=required_terminology,
            project_ids=[],
            schedule_ids=[],
            auto_generated=False
        )

        db.add(scenario)
        db.commit()
        db.refresh(scenario)

        logger.info(f"‚úÖ Manual scenario created: {scenario.id}")

        return {
            "id": str(scenario.id),
            "title": scenario.title,
            "description": scenario.description,
            "scenarioText": scenario.scenario_text,
            "language": scenario.language,
            "difficulty": scenario.difficulty,
            "category": scenario.category,
            "roles": scenario.roles,
            "requiredTerminology": scenario.required_terminology,
            "autoGenerated": scenario.auto_generated,
            "createdAt": scenario.created_at.isoformat()
        }
